---
metaTitle: Build flavors for different version of same class
title: Build flavors for different version of same class
---

## Context

I've got a project, structured like this:



```
project/
   |
   |---src/
        |---flavorA2/
        |      |
        |      |---java/
        |      |     |---com.abc.flavorA.mk2
        |      |                 |-----classA.java
        |      |                 |-----classB.java
        |      |---res/
        |      |---AndroidManifest.xml
        |
        |---main
        |      |---java/
        |      |     |---com.abc.flavorA
        |      |                 |-----classA.java
        |      |                 |-----classB.java
        |      |                 |-----classC.java
        |      |                 |-----classD.java
        |      |---res/
        |      |    |---drawable/
        |      |    |---layout/
        |      |    |---values/
        |      |         
        |      |---AndroidManifest.xml
        |
        |---flavorA

```

`flavorA` will use the source and assets from `main` completely while `flavorA2` has some small changes in `classA` and `classB` and the package name is also changed to `com.abc.flavorA.mk2`.


I had the `build.gradle` file like this:



```
...
buildTypes {
        release {
            runProguard false
            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.txt'
        }
    }
    productFlavors {
        flavorA2 {
            packageName "com.abc.flavorA.mk2"
            versionCode 2
            versionName "1.0.1"
        }

        flavorA {
            packageName "com.abc.flavorA"
        }
    }
...

```

I run the code by selecting the build variant to `flavorA2`. However the running results shows that the gradle still choose the classes (`classA` and `classB`) from `main` instead of using the changed version inside `flavorA2`.


Am I missing something here?



---

In the main build variant, Class A is `com.abc.flavorA.classA`, and in `flavorA2` it's `com.abc.flavorA.mk2.classA`. These are two different fully-qualified class names and therefore two different classes.


You can't really override entire classes in a flavor. Depending on what you want to do, you might want to look into the `BuildConfig` mechanism -- in short, this is a class that's generated by the build system which can have values or statements that vary depending on the build type and flavor. You can have runtime code that looks at constants in that class and varies its behavior.


See [Android Studio Update 0.4.0 could not find buildConfig()](https://stackoverflow.com/questions/20678118/android-studio-update-0-4-0-could-not-find-buildconfig) for more information on the syntax, but in brief, it looks like this:



```
productFlavors {
    flavor {
      buildConfigField "boolean", "MY_FLAG", "true"
    }
}

```


---

## Notes

- You can access the buildConfig field in this way: if(BuildConfig.MY_FLAG) { ... }
- so is there anyway I can make `flavorA2`'s class to "override" the class in `main`?
- I did once to use flavors for different assets with same code base and that worked, seems this way can't be applied to code if I'm understanding you correctly.
